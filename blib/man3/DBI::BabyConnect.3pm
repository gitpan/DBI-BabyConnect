.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::BabyConnect 3"
.TH DBI::BabyConnect 3 "2007-06-29" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
DBI::BabyConnect \- creates an object that holds a DBI connection to a database
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use DBI::BabyConnect;
.Ve
.PP
.Vb 3
\&  # get a DBI::BabyConnect object to access the database as described by 
\&  # the database descriptor BABYDB_001
\&  my $bbconn = DBI::BabyConnect->new('BABYDB_001');
.Ve
.PP
.Vb 2
\&  # direct all STDERR to be appended to /tmp/error.log
\&  $bbconn->HookError(">>/tmp/error.log");
.Ve
.PP
.Vb 2
\&  # append trace information to /tmp/db.log and print DBI::trace set to level 1
\&  $bbconn->HookTracing(">>/tmp/db.log",1);
.Ve
.PP
.Vb 3
\&  # create the table TABLE1 based on the schema coded in TEST_TABLE.mysql, if
\&  # table TABLE1 is found, then drop it first then recreate it
\&  $bbconn->recreateTable('TEST_TABLE.mysql','TABLE1');
.Ve
.PP
.Vb 2
\&  # insert in table TABLE1
\&  $bbconn->do('INSERT INTO TABLE1 VALUES (10,20)');
.Ve
.PP
.Vb 1
\&  $bbconn->disconnect();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is the base class for all \s-1DBI\s0 connection objects instantiated
by the DBI::BabyConnect module.  A DBI::BabyConnect instance
is an object that holds the database handler attributes and an active \s-1DBI\s0
connection handle to a specific database.
The current module support many drivers that can be loaded by the \s-1DBD\s0, but
it has been tested using the \f(CW\*(C`DBD::MySQL\*(C'\fR, with a limited testing using \f(CW\*(C`DBD::Oracle\*(C'\fR driver
and the \f(CW\*(C`DBD::ODBC\*(C'\fR driver.
The class enclude the fundamental methods to insert, update, and get data from
the database, and it hides the complexity of the many \s-1DBI\s0 methods that are
required otherwise to be programmed by yourself. Programmers do not need
to do binding of data or use the may form of fetch methods.
The methods should work for any database, and currently they have been tested with
MySQL and Oracle.
.Sh "\s-1NOTE\s0"
.IX Subsection "NOTE"
Before using the module DBI::BabyConnect, make sure that you understand how the module \f(CW\*(C`DBI\*(C'\fR works,
and in particular the attributes that can affect a \s-1DBI\s0 connection as such: RaiseError, AutoCommit ...
In addition, if you want to understand how this module work from the inside out, you need to
have knowledge about the following Perl programming topics: how to localize a variable, how to
tie to a file handle, how to redirect \s-1IO\s0, how to redirect Perl signals, and the meaning of \fIexit()\fR,
\&\fIdie()\fR and \s-1DESTROY\s0.
.Sh "Nomenclature and Conventions"
.IX Subsection "Nomenclature and Conventions"
The following conventions are used in this document:
.PP
.Vb 5
\&        $bbconn       a variable that is assigned an instance of a DBI::BabyConnect object
\&        BABYCONNECT   environment variable that is set to the URI where DBI::BabyConnect will find its configuration files
\&        databases.pl  the file that contains descriptors, each of which describe how to connect to a database using DBI
\&        globalconf.pl the file that contains settable flags that will control globally the behavior of a DBI::BabyConnect object
\&        BBCO          a DBI::BabyConnect object
.Ve
.Sh "Architecture of an Application using DBI::BabyConnect"
.IX Subsection "Architecture of an Application using DBI::BabyConnect"
.Vb 7
\&        +-----------------+
\&        |Perl             |   +----------------+
\&        |script           |   |                |---|BBCO1|--|DBI XYZ Driver|----|XYZ Engine|----|some database| 
\&        |using            |---+DBI::BabyConnect|---|BBCO2|--|DBI XYZ Driver|----|XYZ Engine|----|some database| 
\&        |DBI::BabyConnect |   |                |--- ...
\&        |                 |   +----------------+
\&        +-----------------+
.Ve
.PP
The DBI::BabyConnect defines an instance
.PP
The \s-1XYZ\s0 driver can be any driver that is loaded by \s-1DBI\s0. The current distribution has
been tested with MySQL and Oracle.
.PP
\&\s-1BBCO\s0's do not need to be using the same driver, for instance \s-1BBCO1\s0 can be using MySQL
driver and \s-1BBCO2\s0 can be using an Oracle driver.
.SH "USAGE"
.IX Header "USAGE"
This class has the following methods:
.ie n .Sh "new( $descriptor )"
.el .Sh "new( \f(CW$descriptor\fP )"
.IX Subsection "new( $descriptor )"
Given a valid database descriptor name, this method returns a DBI::BabyConnect object 
connected to the datasource that is described by the database descriptor.
In other words, given a valid database descriptor name, this method returns an object
blessed into the appropriate \s-1DBD\s0 driver subclass. The object holds
the attributes of the database handle as initially requested
when instantiating the connection. The object also holds a pointer
or a reference to the active connection.
.PP
The class provides methods to alter the attributes of the active
connection held in the object, allowing to enable or disable the exceptions raised
by the \s-1DBI::DBD\s0 module, along with the print error, the auto commit,
and the rollback of transactions (that pertain to the active database
handle).
.PP
You can call \f(CW\*(C`new()\*(C'\fR with different descriptors, hence allowing you to connect
to multiple data sources from the same program.
.ie n .Sh "HookError( $filename )"
.el .Sh "HookError( \f(CW$filename\fP )"
.IX Subsection "HookError( $filename )"
Given a valid instance of a DBI::BabyConnect object, this method hooks
the \s-1STDERR\s0 filehandle to a filename.
The writing of information to \s-1STDERR\s0 is then directed to the specified file.
This is useful in situations where you want to debug \s-1CGI\s0 programs that
use the DBI::BabyConnect or for developers who want to debug the module
itself. \s-1DBI\s0 error messages will also be redirected to the handle
open by the method \fIHookError()\fR.
.ie n .Sh "HookTracing( $filename [,tracelevel] )"
.el .Sh "HookTracing( \f(CW$filename\fP [,tracelevel] )"
.IX Subsection "HookTracing( $filename [,tracelevel] )"
Given a valid instance of a DBI::BabyConnect object, this method hooks
a filehandle to a filename, and sets the trace flag
of the module to true. The logging of information is then directed to
the specified file. 
.PP
Optionally, if you pass a tracelevel as the second argument, then the
DBI::trace is enabled with that level. Select a level
of 0 for no DBI::trace, 1 for minimal information, 2 for more information, etc.
For instance, if tracelevel is set to 3 then
a select statement (such as \f(CW\*(C`fetchQdaAA()\*(C'\fR) will log extensive information
to the file, writing the result to the file.
Setting the tracelevel to 1 will always reveal the query statements passed
to \s-1DBI\s0.
.PP
In a production environment, it is \fBstrongly\fR recommended that you do not
specify any tracelevel by setting tracelevel to 0 or by not calling
this method \fIHookTracing()\fR at all.
.SH "BABYCONNECT Environment Variable"
.IX Header "BABYCONNECT Environment Variable"
The module DBI::BabyConnect looks for the environment variable \s-1BABYCONNECT\s0 to
locate its configuration directory. The configuration directory holds the
database descriptors file (databases.pl), database configuration files (*.conf files),
a global configuration file (globalconf.pl), and skeletons for \s-1SQL\s0 tables.
.PP
A typical configuration tree is shown below:
.PP
.Vb 11
\&        configuration/
\&        |-- SQL
\&        |   `-- TABLES
\&        |       |-- TEST_BABYCONNECT.mysql
\&        |       |-- TEST_TABLE.mysql
\&        |       `-- TEST_TABLE.ora
\&        `-- dbconf
\&            |-- DATAWAREHOUSE_MAY2007.conf
\&        |-- DATAWAREHOUSE_JUNE2007.conf
\&            |-- databases.pl
\&        `-- globalconf.pl
.Ve
.PP
The \fBglobalconf.pl\fR file contains global configuration parameters that affect
all connections to the data sources. The \fBglobalconf.pl\fR file is explained in the
section \*(L"Database Global Configuration File\*(R".
.PP
The \fBdatabases.pl\fR file contains a set of database descriptors each of which describes
the connection to a data source. The \fBdatabases.pl\fR file is explained in the 
section \*(L"Database Descriptors File\*(R".
.PP
Skeleton tables are located in ./configuration/SQL/TABLES/, these tables are used by
\&\f(CW\*(C`DBI::BabyConnect::recreateTable\*(C'\fR method to drop and recreate database
tables.
.PP
Setting the environment variable can be achieved by exporting the environment
variable. For instance if your configuration directory is in /opt/DBI\-BabyConnect:
	export BABYCONNECT=/opt/DBI\-BabyConnect/configuration
.PP
In a Perl script or a Perl module, you can programmatically set the environment variable in
the \s-1BEGIN\s0 block:
.PP
.Vb 1
\&        BEGIN{ $ENV{BABYCONNECT}='/opt/DBI-BabyConnect/configuration'; }
.Ve
.PP
If you are using persitent DBI::BabyConnect objects by loading the \f(CW\*(C`Apache::BabyConnect\*(C'\fR
module in Apache \s-1MD2\s0, then you need to setup the variable prior to loading
the module; the simplest way is to use the Apache configuration directive PerlSetEnv:
.PP
.Vb 1
\&        PerlSetEnv BABYCONNECT /opt/DBI-BabyConnect/configuration
.Ve
.PP
Refer to \f(CW\*(C`Apache::BabyConnect\*(C'\fR for more information about using DBI::BabyConnect
persistence with Apache \s-1MD2\s0.
.SH "Database Global Configuration File"
.IX Header "Database Global Configuration File"
The \fBglobalconf.pl\fR contains several settable parameters that are
global to the DBI::BabyConnect object. The following is a list of
these parameters:
.PP
\&\*(L"\s-1CALLER_DISCONNECT\s0\*(R"
.PP
\&\*(L"\s-1ON_FAILED_DBIEXECUTE_ROLLBACK_AND_EXIT\s0\*(R"
.PP
\&\*(L"\s-1DBSETTING_FORCE_SINGLESPACE_FOR_EMPTY_STRING\s0\*(R"
.PP
\&\*(L"\s-1ENABLE_STATISTICS_ON_DO\s0\*(R"
.PP
\&\*(L"\s-1ENABLE_STATISTICS_ON_SPC\s0\*(R"
.Sh "\s-1CALLER_DISCONNECT\s0"
.IX Subsection "CALLER_DISCONNECT"
The \fB\s-1CALLER_DISCONNECT\s0\fR enforces a check up on whether the caller has disconnected
or not from \s-1DBI\s0 before DBI::BabyConnect::DESTROY method is called. If you want to
depend on DBI::BabyConnect to disconnect automatically upon the object destruction
then set this to 0. Typically, you do not need to call disconnect on a live DBI::BabyConnect
object, because such an object is always connected with the same \s-1DBI\s0 handle for the duration of the
object.
.PP
Set \s-1CALLER_DISCONNECT\s0 to 1 if you want to explicitly call DBI::BabyConnect::disconnect on
a live DBI::BabyConnect object so that you disconnect the obejct from \s-1DBI\s0 yourself.
Whenever you call DBI::BabyConnect::disconnect or whenever the DBI::BabyConnect
object is destroyed it will check whether you have explicitly disconnected or not, and print
to \s-1STDERR\s0 the state of your DBI::BabyConnect. It will also check if you are trying to
disconnect on an already disconnected DBI::BabyConnect object. Such information is useful to keep you
in control of the \s-1DBI\s0 handle.
.PP
For simplicity, set CALLER_DISCONNECT=0, to delegate the disconnection from
\&\s-1DBI\s0 to DBI::BabyConnect object.
.Sh "\s-1ON_FAILED_DBIEXECUTE_ROLLBACK_AND_EXIT\s0"
.IX Subsection "ON_FAILED_DBIEXECUTE_ROLLBACK_AND_EXIT"
You may not need to set \s-1ON_FAILED_DBIEXECUTE_ROLLBACK_AND_EXIT\s0
to 1 to rollback if you call \fIexit()\fR from within your program
(since \fIexit()\fR will eventually call DBI::BabyConnect::DESTROY),
or if you end the class or program that uses DBI::BabyConnect
(as the \s-1DESTROY\s0 is the last to be called even in Apache::BabyConnect)
In either case, whenever \s-1DESTROY\s0 is called, if the autorollback is 1 and autocommit is 0
and the \s-1DBI\s0 execute has returned with failure, then the rollback is in effect.
.PP
The caller can always catch and check the return value of a DBI::BabyConnect method
to see if it has failed a \s-1DBI\s0 execute. Typically DBI::BabyConnect methods return undef
whenever a \s-1DBI\s0 execute fails and therefore the caller can check the return
value and decide on whether to call the DBI::BabyConnect object method rollback himself or not,
therefore allowing the caller to continue to work with the instance of DBI::BabyConnect object
and its open \s-1DBI\s0 connection.
Yet, you can configure the behavior of the DBI::BabyConnect object methods globally
and tell the object methods to automatically rollback and exit on failure.
.PP
This option is settable and will work only if AutoRollback is in effect for the
\&\s-1DBI\s0, because DBI::BabyConnect objects delegate all rollbacks to the \s-1DBI\s0 itself.
\&\s-1DBI\s0 rollback is in effect if and only if:
  RaiseError is 0 (it should be off because otherwise the \s-1DBI\s0 would have exited earlier due to the error)
  AutoCommit is 0 (\s-1DBI\s0 will have no effect on rollback is AutoCommit is set to 1)
DBI::BabyConnect will keep track of the success or failure of \s-1DBI\s0 \fIexecute()\fR, hence deciding on
what to do on failure.
#
\&\s-1DBI\s0 will not exit if the conditions on the rollback are not met, but it will
continue without effectively rolling back.
#
For these DBI::BabyConnect objects that have been instantiated by loading the
DBI::BabyConnect with \s-1PERSISTENT_OBJECT_ENABLED\s0 set to 1
   use DBI::BabyConnect 1, 1
this option will do a rollback but the \fIexit()\fR is redirected to \fIApache::exit()\fR as it
is documented by mod_perl, in which case only the perl script will exit at this point.
Refer to perl/testbaby_rollback.pl
If for any reason the \s-1HTTP\s0 child is terminated, or the \fICORE::exit()\fR is called, or \fICORE::die()\fR
is called, or anything that will terminate the program and call the \s-1DESTROY\s0 of a DBI::BabyConnect
instance, then this \s-1DESTROY\s0 will still check to see if a rollback conditions are met
to do an effective rollback; this is different than the behavior of other application
that do persistence using Apache, as the mechanism of rollback is carried externally of Apache
handlers and is being dispatched within the DBI::BabyConnect object itself.
.Sh "\s-1DBSETTING_FORCE_SINGLESPACE_FOR_EMPTY_STRING\s0"
.IX Subsection "DBSETTING_FORCE_SINGLESPACE_FOR_EMPTY_STRING"
When inserting new data, a scalar that refer to an empty string "" will normally
keep the default value of the attribute in the database, i.e. \s-1NULL\s0. You can
set DBSETTING_FORCE_SINGLESPACE_FOR_EMPTY_STRING=1 to force the writing of
a single space instead of keeping the default \s-1NULL\s0.
.Sh "\s-1ENABLE_STATISTICS_ON_DO\s0"
.IX Subsection "ENABLE_STATISTICS_ON_DO"
When \s-1ENABLE_STATISTICS_ON_DO\s0 is set to 1, a DBI::BabyConnect object maintains
a table to hold statistics about the \fIdo()\fR's requested by identifying each entry
with the query string being passed to the \fIdo()\fR method. The programmer can
then call \fIget_do_stat()\fR to get the object that hold the statistics.
Do not enable this unless you need to collect statistics, for instance in
data warehousing environment the queries to \fIdo()\fR are limited in format
and are time consuming, so you may desire to collect statistics about these
\&\fIdo()\fR's queries.
.Sh "\s-1ENABLE_STATISTICS_ON_SPC\s0"
.IX Subsection "ENABLE_STATISTICS_ON_SPC"
When \s-1ENABLE_STATISTICS_ON_SPC\s0 is set to 1, a DBI::BabyConnect object maintains
a table to hold statistics about the \fIspc()\fR's requested by identifying each entry
with the stored procedure name passed to the \fIspc()\fR method. The programmer can
then call \fIget_spc_stat()\fR to get the object that hold the statistics.
Do not enable this unless you need to collect statistics, for instance in
data warehousing environment the stored procedure names passed \fIspc()\fR are limited in number
and are time consuming, so you may desire to collect statistics about these
\&\fIspc()\fR's stored procedures.
.SH "Database Descriptors File"
.IX Header "Database Descriptors File"
The databases.pl file holds a set of database descriptors. The database descriptor
is an object whose attributes describe a specific connection to a data source, that is
to what database to connect, how to connect, and to handle the connection
programmatically in case of failure.
.PP
.Vb 15
\&        BABYDB_001 =>
\&        {
\&                Driver => 'Mysql',
\&                Server=>'',
\&                UserName=>'admin',
\&                Password=>'adminxyz',
\&                # Mysql defines a database name, CAREFUL it may be case sensitive!
\&                DataName=>'BABYDB',
\&                PrintError=>1,
\&                RaiseError=>1,
\&                AutoRollback => 1,
\&                AutoCommit=>1,
\&                LongTruncOk=>1,
\&                LongReadLen => 900000,
\&        }
.Ve
.PP
A descriptor specifies the driver name, the database name, and how to authenticate to connect
to the database. DBI::BabyConnect allows you to have multiple descriptors each of which
can be used by a DBI::BabyConnect object instance to connect to the data source.
.PP
Because it is possible to have multiple descriptors, and you can instantiate multiple
DBI::BabyConnect objects, then it is possible to connect to several data sources 
from a single program. For example, it is possible to connect concurrently from the same
program to MySQL database located on a server A, to another MySQL database located
on server B, to an Oracle database located on server C, and so on.
.Sh "The database handle attributes"
.IX Subsection "The database handle attributes"
For each of the active database connection, there are six attributes
that are defined:
.IP "1 RaiseError" 2
.IX Item "1 RaiseError"
.PD 0
.IP "2 PrintError" 2
.IX Item "2 PrintError"
.IP "3 AutoCommit" 2
.IX Item "3 AutoCommit"
.IP "4 AutoRollback" 2
.IX Item "4 AutoRollback"
.IP "5 LongTruncOk" 2
.IX Item "5 LongTruncOk"
.IP "6 LongReadLen" 2
.IX Item "6 LongReadLen"
.PD
.PP
The first two attributes, LongTruncOk and LongReadLen, are defined for the
duration of the active database connection. These two attributes cannot be
altered after instantiating an initial connection.
.PP
The first four attributes, RaiseError, PrintError, AutoCommit, and AutoRollback,
are boolean attributes and can be modified during the run time of a DBI::BabyConnect
object. To change or check any of these attributes, the class provides setter
and getter methods.
.PP
For an instance of a DBI::BabyConnect object, the flag attributes can be altered during
run time. Altering the flag attributes allow you to control the behavior of
an active database connection before and during each query (i.e.
using a \f(CW\*(C`do()\*(C'\fR, \f(CW\*(C`spc()\*(C'\fR, \f(CW\*(C`getQdaAA()\*(C'\fR, \f(CW\*(C`getTdaAA()\*(C'\fR, etc). 
.PP
When the attribute AutoRollback is set to true, the module will handle
the rollback of a transaction on failure; this assumes that the AutoCommit has
been set to false. If the AutoCommit has been set to true, and a database
transaction fails than the AutoRollback has no effect, and the \s-1DBD::DBI\s0 will
return a string \fIrollback ineffective with AutoCommit enabled\fR.
Note also that you need to have \*(L"\s-1ON_FAILED_DBIEXECUTE_ROLLBACK_AND_EXIT\s0\*(R" set to 1.
.SH "Connection Attribute Functions"
.IX Header "Connection Attribute Functions"
This class contains several functions to retrieve, store, or set the attributes 
of the DBI::BabyConnect object.
.Sh "getActiveDescriptor( )"
.IX Subsection "getActiveDescriptor( )"
\&\fIgetActiveDescriptor()\fR returns the information about the current DBI::BabyConnect object
that is initialized with the specified descriptor.
.PP
\&\fIgetActiveDescriptor()\fR takes an optional argument, a hash reference,
the method returns the information in that hash reference.
.PP
If no argument is passed then the method returns a string of information describing
the DBI::BabyConnect object.
.PP
You can gather the DBI::BabyConnect object itself by passing a hash reference, then
dereferencing it. For example:
.PP
.Vb 3
\&    $bbconn-> getActiveDescriptor($h);
\&    my $bbconn2 = $$h{Connection};
\&        # now $bbconn and $bbconn2 are the same
.Ve
.PP
.Vb 2
\&    my $bbconn3 = $bbconn-> connection;
\&    # now $bbconn, $bbconn2, and $bbconn3 are all the same
.Ve
.PP
.Vb 2
\&    # you can get the DBI::db handle used by the DBI::BabyConnect
\&    my $dbh = $$h{DBIhandle};
.Ve
.PP
Usually you do not need to use the method \fIgetActiveDescriptor()\fR. This method is provided
to experiment with multi-threaded DBI::BabyConnect objects.
.Sh "saveLags( )"
.IX Subsection "saveLags( )"
Given a \f(CW\*(C`DBI::BabyConnect\*(C'\fR object, this method save the attribute flags:
PrintError, RaiseError, AutoCommit, and AutoRollback, to a temporary object.
.Sh "restoreLags( )"
.IX Subsection "restoreLags( )"
Given a \f(CW\*(C`DBI::BabyConnect\*(C'\fR object, this method restore the attribute flags:
PrintError, RaiseError, AutoCommit, and AutoRollback, from the temporary object.
.Sh "resetLags( )"
.IX Subsection "resetLags( )"
Given a \f(CW\*(C`DBI::BabyConnect\*(C'\fR object, this method reset the attribute flags:
PrintError, RaiseError, AutoCommit, and AutoRollback, to their original values
as they have been set at object initialization. These are the values of
the \*(L"database descriptor\*(R" used when creating the \f(CW\*(C`DBI::BabyConnect\*(C'\fR object.
.Sh "connection( )"
.IX Subsection "connection( )"
Given a \f(CW\*(C`DBI::BabyConnect\*(C'\fR object, this method returns the DBI::db handle to
the data source to which the object is connected.
.Sh "dbname( )"
.IX Subsection "dbname( )"
Given a \f(CW\*(C`DBI::BabyConnect\*(C'\fR object, this method returns the name of the
data source to which the object is connected.
.Sh "dbserver( )"
.IX Subsection "dbserver( )"
Given a \f(CW\*(C`DBI::BabyConnect\*(C'\fR object, this method returns the server
name where the data source is located.
.Sh "dbdriver( )"
.IX Subsection "dbdriver( )"
Given a \f(CW\*(C`DBI::BabyConnect\*(C'\fR object, this method returns the driver name
being used by the object to connect to the data source.
.Sh "dbusername( )"
.IX Subsection "dbusername( )"
Given a \f(CW\*(C`DBI::BabyConnect\*(C'\fR object, this method returns the username used
to authenticate the connection to the data source.
.Sh "printerror( )"
.IX Subsection "printerror( )"
Given a \f(CW\*(C`DBI::BabyConnect\*(C'\fR object, this method returns the state of the
\&\fBPrintError\fR attribute flag as it is being set to the active connection of the object. 
.PP
If you pass an argument (0 or 1) to this method, then the method
acts as a setter, setting the flag to that value.
.PP
If PrintError is set to true (1) then the \s-1DBI\s0 will print warning and
error to \s-1STDERR\s0.
.PP
Initially, when a DBI::BabyConnect object is created (using the \f(CW\*(C`new()\*(C'\fR method),
this flag is set to the value read from the database descriptor.
.PP
The current state of the flag can also be revealed by printing the
information string returned by \f(CW\*(C`get_handle_flags()\*(C'\fR
.Sh "raiseerror( )"
.IX Subsection "raiseerror( )"
Given a \f(CW\*(C`DBI::BabyConnect\*(C'\fR object, this method returns the state of the
\&\fBRaiseError\fR attribute flag as it is being set to the active connection of the object. 
.PP
If you pass an argument (0 or 1) to this method, then the method
acts as a setter, setting the flag to that value.
.PP
If RaiseError is set to true (1) then the connection will break if
the \s-1DBD::DBI\s0 encounter an error, that is because \s-1DBD::DBI\s0 will raise
the error and exit.
.PP
Initially, when a DBI::BabyConnect object is created (using the \f(CW\*(C`new()\*(C'\fR method),
this flag is set to the value read from the database descriptor.
.PP
The current state of the flag can also be revealed by printing the
information string returned by \f(CW\*(C`get_handle_flags()\*(C'\fR
.Sh "autorollback( )"
.IX Subsection "autorollback( )"
Given a \f(CW\*(C`DBI::BabyConnect\*(C'\fR object, this method returns the state of the
\&\fBAutoRollback\fR attribute flag as it is being set to the active connection of the object. 
.PP
If you pass an argument (0 or 1) to this method, then the method
acts as a setter, setting the flag to that value.
.PP
If AutoRollback is set to true (1) then if a \s-1DBI\s0 execute fails within
a transaction, DBI::BabyConnect rollback.
.PP
Initially, when a DBI::BabyConnect object is created (using the \f(CW\*(C`new()\*(C'\fR method),
this flag is set to the value read from the database descriptor.
.PP
Note, that the attribute AutoRollback is not one of the predefined attributes
used by the \s-1DBI\s0 module, and its behavior is defined internally to the
class DBI::BabyConnect.
The AutoRollback flag has no effect if set to true and AutoCommit flag
(settable with \f(CW\*(C`autocommit()\*(C'\fR) is set to true. A rollback is not possible
if AutoCommit is set to true.
.PP
The current state of the flag can also be revealed by printing the
information string returned by \f(CW\*(C`get_handle_flags()\*(C'\fR
.Sh "autocommit( )"
.IX Subsection "autocommit( )"
Given a \f(CW\*(C`DBI::BabyConnect\*(C'\fR object, this method returns the state of the
\&\fBAutoCommit\fR attribute flag as it is being set to the active connection of the object.
.PP
If you pass an argument (0 or 1) to this method, then the method
acts as a setter, setting the flag to that value.
.PP
If AutoCommit is set to true (1) then all transactions are being committed
to the database. If AutoCommit is set to true (1) then it is not possible
to rollback, and calling the \fIrollback()\fR will have no effect.
.PP
Initially, when a DBI::BabyConnect object is created (using the \f(CW\*(C`new()\*(C'\fR method),
this flag is set to the value read from the database descriptor.
.PP
The current state of the flag can also be revealed by printing the
information string returned by \f(CW\*(C`get_handle_flags()\*(C'\fR
.Sh "longtruncok( )"
.IX Subsection "longtruncok( )"
Given a \f(CW\*(C`DBI::BabyConnect\*(C'\fR object, this method returns the state of the
\&\fBLongTruncOk\fR attribute flag as it is being set to the active connection of the object.
.Sh "longreadlen( )"
.IX Subsection "longreadlen( )"
Given a \f(CW\*(C`DBI::BabyConnect\*(C'\fR object, this method returns the value of the
\&\fBLongReadLen\fR attribute as it is being set to the active connection of the object.
.Sh "storeLags( )"
.IX Subsection "storeLags( )"
Store temporary the attributes of the connection.
.Sh "restoreLags( )"
.IX Subsection "restoreLags( )"
Restore the attributes of the connection as they have been stored using the storeLags.
.Sh "resetLags( )"
.IX Subsection "resetLags( )"
Reset the attributes of the connection as they have been initially set by the initial
database descriptor.
.SH "Class Methods"
.IX Header "Class Methods"
Once a new DBI::BabyConnect instance is created successfully, then the instance has
a established a successfull database connection to a data source, and the \f(CW\*(C`new()\*(C'\fR class
method will return a blessed object reference holding a database
connection handle which is established with the \s-1DBI\s0, and storing internally
within the class object the initial database attributes.
We will refer to the \fIinstance object returned by DBI::BabyConnect\fR simply
with the \fI\s-1BBCO\s0\fR.
.PP
For each DBI::BabyConnect object that has been instantiated with the \f(CW\*(C`new()\*(C'\fR method
of the \f(CW\*(C`DBI::BabyConnect\*(C'\fR module, the module provides the
following methods:
.ie n .Sh "recreateTable( $table_template\fP, \f(CW$table_name )"
.el .Sh "recreateTable( \f(CW$table_template\fP, \f(CW$table_name\fP )"
.IX Subsection "recreateTable( $table_template, $table_name )"
Read a table template and create a table named \f(CW$table_name\fR. If the table name
exist then it will be dropped then recreated.
.ie n .Sh "getTcount( $table\fP, \f(CW$column\fP, \f(CW$where )"
.el .Sh "getTcount( \f(CW$table\fP, \f(CW$column\fP, \f(CW$where\fP )"
.IX Subsection "getTcount( $table, $column, $where )"
\&\fIgetTcount()\fR works on a single table. Given a table name, get the count on the columns
where the \f(CW$where\fR condition is satisfied.
.Sh "sqlbnd( )"
.IX Subsection "sqlbnd( )"
\&\fIsqlbnd()\fR executes a \s-1SQL\s0 whose elements are specified by order and by type.
.PP
.Vb 1
\&    sqlbnd( $sql, $o_bnd, $o_typ )
.Ve
.PP
$sql is the \s-1SQL\s0 to be executed by the method
.PP
$o_bnd is a pseudo hash with the first element a hash reference that specify the order
in which the elements will appear, and the following elements specify the ...
.PP
$o_typ is a hash reference that specify mapping each data element to their \s-1SQL\s0 type.
If you are using MySQL, you can set \f(CW$o_typ\fR to undef, since the MySQL \s-1DBD\s0 driver knows
how to handle the type. If you are using a different database than MySQL, such as
Oracle, then you need to specify the proper \s-1SQL\s0 type mapping for the elements. For instance,
when inserting a \s-1BLOB\s0 into Oracle, the \s-1SQL\s0 type for the \s-1BLOB\s0 element is 113.
.PP
Consult your driver manual for the \s-1SQL\s0 types of the driver you are using. Recall that
a DBI::BabyConnet object is initially created with the driver that is specified by
the database descriptor (see \*(L"Database Descriptors File\*(R").
.ie n .Sh "do( $query )"
.el .Sh "do( \f(CW$query\fP )"
.IX Subsection "do( $query )"
.Vb 2
\& On success:
\&   return the number of rows affected
.Ve
.PP
.Vb 4
\& On failure:
\&    return undef on failure   if raiseerror=0 and autorollback=0
\&    will die (calling destroy) and will explicit-rollback and will not return if raiseerror=0 and autorollback=1
\&    will die (calling destroy) and will not return  if raiseerror=1 and autorollback=0
.Ve
.ie n .Sh "spc( $o\fP, \f(CW$stproc )"
.el .Sh "spc( \f(CW$o\fP, \f(CW$stproc\fP )"
.IX Subsection "spc( $o, $stproc )"
Calls the stored procedure \f(CW$stproc\fR whose parameters are prepared from the pseudo-hash
passed in \f(CW$o\fR.
.PP
Calls the stored procedure \f(CW$stproc\fR. The binding parameters is derived from the
object \f(CW$o\fR, which is a pseudo\-hash, such that the array of the pseudo-hash itself maintains the order
of the elements to be passed to the stored procedure, and these elements that are initially undefinied (at entry)
will be set with the returned values of the stored procedure (when returning).
Returns 1 on success and 0 on failure. The pseudo-hash contains the data values
returned by the stored procedure.
.PP
spc method, takes a pseudo-hash as a first argument, and the
fully specified name of a stored procedure name as the second
argument. The method will setup the bindings of the parameters
before executing the stored procedure; if the value passed to
a parameter is undef, then the method will do a bind_param_inout,
otherwise it will simply bind it as bind_param.
On return, the method will set undefined parameters of the pseudo-hash
to the known values returned from the stored procedure.
.PP
Currently, this method will call \fIdie()\fR if it fails to execute the \s-1SQL\s0 of the stored procedure.
.ie n .Sh "fetchQdaO( $qry, [,$recref] [,\e@list] [,@bindparams] )"
.el .Sh "fetchQdaO( \f(CW$qry\fP, [,$recref] [,\e@list] [,@bindparams] )"
.IX Subsection "fetchQdaO( $qry, [,$recref] [,@list] [,@bindparams] )"
.Vb 13
\& 1- the SQL query 
\& 2- an optional record hash reference whose attributes will be set to the ones of the fetched record.
\&   If you do not specify a hash reference, then a new hash reference is created within this method
\&   to hold the result to be returned to the caller.
\&   On DBI error, this method will return undef.
\& 3- optional array reference to list the fields that you specified in the query. The listed elements
\&   must be ordered the same way as they are listed in the query or you will end up with unpredictable
\&   results. Although you will be constrained by following the order of the fields as they
\&   appear in the query, this option allows a more efficient memory usage when
\&   retrieving fields that consume large chunk of memory (i.e. BLOB) because it does not do mutiple
\&   memory allocation or copy by value when fetching the fields, rather it assign the references
\&   of the fetched data to appropriate fields of the records.
\& 4- an optional list of binding params
.Ve
.PP
.Vb 3
\& use it when records are unique, since it returns a single (first encountered) record
\& record result is in $hh or \e%REC
\& return 1 on success, 0 if no record is found, -1 if DBI error
.Ve
.ie n .Sh "fetchQdaAA( $qry [,$aaref] [,$href] [,@bindparams] )"
.el .Sh "fetchQdaAA( \f(CW$qry\fP [,$aaref] [,$href] [,@bindparams] )"
.IX Subsection "fetchQdaAA( $qry [,$aaref] [,$href] [,@bindparams] )"
Given an active database connection, this method takes a query
string as an argument to fetch database and return it an a 2D
array. The method uses the \s-1DBI\s0 \fIprepare()\fR method, and binds any
parameters if provided in the method argument, then \s-1DBI\s0 \fIexecute()\fR
the query, and finally fetch the data by iterating through
the \s-1DBI\s0 cursor fetchrow_arrayref.
.PP
The \f(CW$extra_href\fR is optional and is a reference to a struc that
holds two attributes: \fBmax_rows\fR and \fB\s-1INCLUDE_HEADER\s0\fR.
.PP
\&\fIfetchQdaAA()\fR is given a \s-1SQL\s0 query to return data into an array of array, that is
into a 2D array.
.PP
\&\fIfetchQdaAA()\fR takes four parameters in that order:
    1\- the \s-1SQL\s0 query
    2\- an optional array reference to hold the returned fetched records
    3\- an optional hash reference to specify the following \s-1INCLUDE_HEADER\s0, \s-1MAX_ROWS\s0 (default to 1, everything)
    4\- an optional list of binding params
.PP
.Vb 3
\&    my $qry = qq{SELECT * FROM FR_XDRTABLE1 WHERE ID < ? AND FLD1 = ? };
\&    my $rows = $dbhandle-> fetchQdaAA($qry, {INCLUDE_HEADER=>1,MAX_ROWS=>10});
\&    my $rows = $dbhandle-> fetchQdaAA($qry,14,'u4_1');
.Ve
.PP
.Vb 3
\&    # define an array ref, fill it in and expand it
\&    my $rows=[]; # important to mark it as an array ref before calling below
\&    $dbhandle-> fetchQdaAA($qry,$rows,{INCLUDE_HEADER=>1,MAX_ROWS=>1},14,'u4_1');
.Ve
.ie n .Sh "fetchTdaAA( $table\fP, \f(CW$selection\fP, \f(CW$where [,$aaref] [,@bindparams] )"
.el .Sh "fetchTdaAA( \f(CW$table\fP, \f(CW$selection\fP, \f(CW$where\fP [,$aaref] [,@bindparams] )"
.IX Subsection "fetchTdaAA( $table, $selection, $where [,$aaref] [,@bindparams] )"
\&\f(CW\*(C`fetchTdaAA()\*(C'\fR method
.PP
.Vb 1
\&    fetchTdaAA('FR_XDRTABLE1', ' * '  ,  " id < ? AND FLD1 = ? ",54,'u4_1')
.Ve
.PP
.Vb 7
\& 1- table name
\& 2- what to select that follows the SELECT keyword
\& 3- condition that follows the WHERE keyword
\& 4- optional array reference that is extended with the new elements being selected. If no array reference
\&   is passed, then a new array is created within this method to hold the result. The method returns
\&   a reference to the array that holds the final results; otherwise, it returns undef in case there is no result.
\& 5- binding parameters
.Ve
.ie n .Sh "fetchTdaAO( $table\fP, \f(CW$selection\fP, \f(CW$where [,$ahref] [,$href] [,@bindparams] )"
.el .Sh "fetchTdaAO( \f(CW$table\fP, \f(CW$selection\fP, \f(CW$where\fP [,$ahref] [,$href] [,@bindparams] )"
.IX Subsection "fetchTdaAO( $table, $selection, $where [,$ahref] [,$href] [,@bindparams] )"
The method \fIfetchTdaAO()\fR retrieves object records of data using fetchrow_hashref
.PP
fetchTdaAO takes the following arguments:
.PP
1\- the table name
2\- what to select from the table, that is what will follow the \s-1SELECT\s0 keyword. This parameter type will determine
   the type of the array reference being returned by this method as shown below:
.PP
.Vb 6
\&    Selection                                          Return
\&    ------------------------------------------         -----------------
\&    a literal: "ID,UID,TMD0,FLD1,CHANGEDATE_T"         Array of Objects
\&    a wildcard * literal :  " * "                      Array of Objects
\&    a hash ref: {...}                                  Array of Objects
\&    an array: ('ID','UID','TMD0')                      Array of Array (preserving the order)
.Ve
.PP
3\- condition that follows the \s-1WHERE\s0 keyword
4\- An optional array reference set by the caller, allowing to expand an already allocated array
   with the new records being selected. If no array reference
   is passed, then a new array is created within this method to hold the result. The method returns
   a reference to the array that holds the final results; otherwise, it returns undef in case there is no result.
5\- binding parameters
.SH "Closing Functions"
.IX Header "Closing Functions"
After you have executed a \s-1SQL\s0 transaction with a DBI::BabyConnect object, usually \s-1DBI\s0 requires
that you end the transaction by committing if it passes, by rolling back or raising error if it
fails, by calling finish on the DBI::db handle, and by disconnecting the handle.
.PP
Usually you do not need to call any of the functions aformentioned because 
DBI::BabyConnect will do that transparently for you. You use DBI::BabyConnect so that
you can work with an object whose connection is persisted to a data source, and
the object will do all clean up upon object destruction.
.PP
The following functions are provided so that if you chose to porte an application that
uses \s-1DBI\s0 directly, you can easily make use of DBI::BabyConnect without making extensive changes
to the application.
.Sh "commit( )"
.IX Subsection "commit( )"
Call commit on the handle open by DBI::BabyConnect object. Provided to ease portability
of programs using \s-1DBI\s0 directly.
.Sh "rollback( )"
.IX Subsection "rollback( )"
\&\fIrollback()\fR delegates the rollback to DBI::rollback method, except that the localization
of variable will take place prior to calling DBI::rollback. Usually, you do not need
to call the rollback explicitly, as it is being called from other methods (i.e. \fIDBI::BabyConnect::do()\fR
or \fIDBI::BabyConnect::sqlbnd()\fR, etc.) whenever a \s-1DBI\s0 \fIexeucte()\fR fails and the rollback
conditions are met. Refer to \fIDBI::BabyConnect::do()\fR and \s-1ON_FAILED_DBIEXECUTE_ROLLBACK_AND_EXIT\s0
settable variable for more information on how this method is being invoked.
.PP
You can always call this method explicitly if you wish to handle the rollback from within
your program.
.Sh "finish( )"
.IX Subsection "finish( )"
Call finish on the cursor held by DBI::BabyConnect object. Provided to ease portability
of programs using \s-1DBI\s0 directly.
.Sh "disconnect( )"
.IX Subsection "disconnect( )"
Call the disconnect explicitly on a DBI::BabyConnect object, hence delegating the
disconnection to \s-1DBI\s0 disconnect. You do not need to disconnet during the life time
of a DBI::BabyConnect object, however, if you do so, then you need to \f(CW\*(C`reconnect()\*(C'\fR 
by calling \f(CW\*(C`DBI::BabyConnect::reconnect()\*(C'\fR if you want to keep on using the same
DBI::BabyConnect object.
.PP
\&\fIdisconnect()\fR will call \s-1DBI\s0 disconnect on the DBI::BabyConnect object. Usually you need
to disconnect the DBI::BabyConnect object from the data source once you are done
working with the object. Yet, you can rely on DBI::BabyConnect to do the disconnection
upon exit or object destruction, by setting \f(CW\*(C`CALLER_DISCONNECT\*(C'\fR to 0. Refer to \*(L"\s-1CALLER_DISCONNECT\s0\*(R".
.SH "Error Functions"
.IX Header "Error Functions"
.Sh "dbierror"
.IX Subsection "dbierror"
Returns the \f(CW$DBI::err\fR as returned by the \s-1DBD::DBI\s0 for the active dbi handler.
.Sh "dbiconfess"
.IX Subsection "dbiconfess"
Not implemented! (next release)
.SH "Statistical Functions"
.IX Header "Statistical Functions"
DBI::BabyConnect can collect statistics about the cumulative run time, and the system
time consumed by DBI::BabyConnect objects (while accessing the data sources).
.PP
The DBI::BabyConnect::getStatCC returns statistics about all DBI::BabyConnect objects
whenever using DBI::BabyConnect with connection caching and persistence.
.PP
There following three statistical functions collect statistics per DBI::BabyConnect object:
get_do_stats, get_spc_stats, get_running_time
.Sh "getStatCC"
.IX Subsection "getStatCC"
\&\fIgetStatCC()\fR returns the statistics collected on the open \s-1DBI\s0 handles owned by
the DBI::BabyConnect objects. The caching of the handles will only work whenever
you instantiate the DBI::BabyConnect by enabling \s-1ENABLE_CACHING\s0 and \s-1PERSISTENT_OBJECT_ENABLED\s0
For example:
  use DBI::BabyConnect 1,1;
will load the DBI::BabyConnect and set \s-1ENABLE_CACHING\s0 and \s-1PERSISTENT_OBJECT_ENABLED\s0 to
true.
.PP
use DBI::BabyConnect (1,1) is typically called whenever using Apache::BabyConnect or
whenever loading the module from a Perl script that is run under mod_perl.
.PP
This method \fIgetStatCC()\fR takes one optional argument:
 \- if you do not pass any argument, then this method will return a string containing the statistics collected on all open handles
 \- if you pass a hash reference as the first argument then the statistics table is copied to this hash reference
   and the method will also return the reference to that hash
 \- if you pass anything else (as a string), then the method will return a hash reference containing the statistics collected
   on the cached descriptor that matches that string.
.Sh "get_running_time"
.IX Subsection "get_running_time"
\&\fIget_running_time()\fR returns a string containing time related information about the DBI::BabyConnect object.
The string returned has the following format:
cumulative-system-time / added-system-time / total-run-time
.PP
All three times are expressed in seconds and 1/100 second.
cumulative-system-time represents the system+user time used by the DBI::BabyConnect object
added-system-time represents the system+user time slices added per each \s-1DBI\s0 method call, and they hould add up to be close to cumulative-system-time
total-run-time represents the time since the DBI::BabyConnect object was instantiated
.Sh "get_do_stats"
.IX Subsection "get_do_stats"
This method \fIget_do_stat()\fR takes one optional argument:
 \- if you do not pass any argument, then this method will return a string containing the statistics collected
 \- if you pass a hash reference as the first argument then the \fIdo()\fR's statistics table is copied to this hash reference
   and the method will also return the reference to that hash
 \- if you pass anything else (as a string), then the method will return a hash reference containing the statistics collected
   on the \fIdo()\fR query that match that string.
.PP
\&\fIget_do_stat()\fR returns the statistics collected on the \fIdo()\fR method. You should have
enabled to collect the statistics by seting \s-1ENABLE_STATISTICS_ON_DO\s0 to 1, otherwise
the statictics table is empty.
Before setting \s-1ENABLE_STATISTICS_ON_DO\s0 to 1, just know what you are doing otherwise
you will imply a huge penalty on the DBI::BabyConnect object by acquiring an unecessary
data structure to hold the statistics of all \fIdo()\fR's statement. Refer to the section
\&\*(L"\s-1ENABLE_STATISTICS_ON_DO\s0\*(R".
.PP
I added the \s-1ENABLE_STATISTICS_ON_DO\s0 for some system integrators working in data warehouse,
where the \fIdo()\fR robots are usually repetitive for the same set of queries and are time consuming.
If your \fIdo()\fR query is taking too long, and your \fIdo()\fR queries are limited in number, and
you want to know how many time the same query is being called (and how much system time it is
consuming) then enable \s-1ENABLE_STATISTICS_ON_DO\s0, and use the method \fIget_do_stat()\fR to get the
statistics of all your \fIdo()\fR's that have served by a DBI::BabyConnect object.
.Sh "get_spc_stats"
.IX Subsection "get_spc_stats"
Similar to "get_do_stats but statistics are collected on Stored Procedures whenever
you call \fIspc()\fR.
.SH "Logging and Tracing"
.IX Header "Logging and Tracing"
This module provides a tie to a filehandle so that information can be logged
during run time of the module. In addition, the filehandle can be shared with
the \f(CW\*(C`DBI::trace()\*(C'\fR allowing to redirect the trace output to that file.
.PP
You can initialize the hook after getting the database connection
by simply calling \f(CW\*(C`HookTracing()\*(C'\fR in which case the tracing is
automatically enabled and run time information is printed to the log file.
Refer to \*(L"HookTracing( \f(CW$filename\fR [,tracelevel] )\*(R".
.PP
You can redirect all \s-1STDERR\s0 output to a file by calling \f(CW\*(C`HookError()\*(C'\fR.
Refer to \*(L"HookError( \f(CW$filename\fR )\*(R".
.PP
The hook can be ignored, and therefore no information will be logged. This is useful
in a production environment after the DBI::BabyConnect objects have been tested,
you can simply comment out the hook.
.SH "SUPPORT"
.IX Header "SUPPORT"
Support for this module is provided via the <bbconn@pugboat.com> email
list. A mailing list will soon be provided at babyconnect@pugboat.com.
.SH "AUTHOR"
.IX Header "AUTHOR"
Bassem W. Jamaleddine, <bassem@pugboat.com>
.SH "MAINTAINER"
.IX Header "MAINTAINER"
PUGboat (Processors User Group), <bbconn@pugboat.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2001\-2007 by Bassem W. Jamaleddine, 2007 by the
Processors User Group (PUGboat.COM). All rights reserved. This program
is free software; you can redistribute it and/or modify it under the
same terms as Perl itself, either Perl version 5.8.8 or,
at your option, any later version of Perl 5 you may have available.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Persisting DBI::BabyConnect objects with \fBApache::BabyConnect\fR
.PP
This module is being used by Varisphere Processing Server powering the
web site www.youprocess.com
